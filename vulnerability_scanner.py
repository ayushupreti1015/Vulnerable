import requests
from bs4 import BeautifulSoup
import re
import urllib.parse
import sqlite3
import argparse
from concurrent.futures import ThreadPoolExecutor
import json
import logging
import time
from datetime import datetime
import os
import threading
import queue

# Thread-safe database connection wrapper
class ThreadSafeDBConnection:
    """Thread-safe database connection wrapper"""
    def __init__(self, db_path):
        self.db_path = db_path
        self.connection_queue = queue.Queue()
        self.lock = threading.Lock()
        
        # Create initial connection
        self._init_connection()
        
    def _init_connection(self):
        """Initialize a new database connection"""
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        self.connection_queue.put(conn)
    
    def execute(self, query, params=None):
        """Execute a query and return the results"""
        with self.lock:
            # Get a connection from the queue
            if self.connection_queue.empty():
                self._init_connection()
            
            conn = self.connection_queue.get()
            
            try:
                cursor = conn.cursor()
                if params:
                    cursor.execute(query, params)
                else:
                    cursor.execute(query)
                
                results = list(cursor.fetchall())
                conn.commit()
                lastrowid = cursor.lastrowid
                cursor.close()
                
                # Put the connection back in the queue
                self.connection_queue.put(conn)
                
                return results, lastrowid
            except Exception as e:
                # In case of error, close this connection and create a new one
                conn.close()
                self._init_connection()
                raise e
    
    def close_all(self):
        """Close all database connections"""
        with self.lock:
            while not self.connection_queue.empty():
                conn = self.connection_queue.get()
                conn.close()

# Set up logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("vulnerability_scanner.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("vulnerability_scanner")

class VulnerabilityScanner:
    def __init__(self, base_url, depth=2, threads=5, timeout=10):
        """
        Initialize the vulnerability scanner
        
        Args:
            base_url (str): The base URL to scan
            depth (int): How many levels of links to follow
            threads (int): Number of concurrent threads to use
            timeout (int): Request timeout in seconds
        """
        self.base_url = base_url
        self.depth = depth
        self.threads = threads
        self.timeout = timeout
        self.visited_urls = set()
        self.forms = []
        self.vulnerabilities = []
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        
        # Track scan progress
        self.total_urls = 0
        self.scanned_urls = 0
        self.scan_progress = 0
        self.scan_status = "Initializing"
        
        # Control flags for pause/resume/cancel
        self.is_paused = False
        self.should_cancel = False
        
        # Initialize database
        self.init_database()
    
    def init_database(self):
        """Initialize SQLite database for storing scan results"""
        db_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'vulnerabilities.db')
        self.db = ThreadSafeDBConnection(db_path)
        
        # Create tables if they don't exist
        self.db.execute('''
            CREATE TABLE IF NOT EXISTS scans (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                target_url TEXT,
                scan_date TIMESTAMP,
                completed BOOLEAN,
                total_urls INTEGER DEFAULT 0,
                scanned_urls INTEGER DEFAULT 0,
                progress INTEGER DEFAULT 0,
                status TEXT DEFAULT 'Initializing'
            )
        ''')
        
        self.db.execute('''
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id INTEGER,
                url TEXT,
                vulnerability_type TEXT,
                description TEXT,
                severity TEXT,
                evidence TEXT,
                FOREIGN KEY (scan_id) REFERENCES scans (id)
            )
        ''')
    
    def start_scan(self):
        """Start the vulnerability scan process"""
        logger.info(f"Starting scan of {self.base_url}")
        
        # Track scan progress
        self.total_urls = 0
        self.scanned_urls = 0
        self.scan_progress = 0
        self.scan_status = "Initializing"
        self.is_paused = False
        self.should_cancel = False
        
        # Scan already initialized in the VulnerabilityAPI.start_scan method
        # We'll just update the status in database
        self.scan_status = "Crawling website"
        self.update_scan_status()
        
        try:
            # First crawl to discover all URLs
            self.crawl(self.base_url, self.depth)
            
            # Check if scan was cancelled during crawling
            if self.should_cancel:
                logger.info("Scan cancelled during crawling phase")
                return []
                
            self.total_urls = len(self.visited_urls)
            
            # Update total URLs in database
            self.db.execute(
                "UPDATE scans SET total_urls = ? WHERE id = ?",
                (self.total_urls, self.scan_id)
            )
            
            # Reset for actual scanning
            self.scanned_urls = 0
            self.scan_status = "Scanning for vulnerabilities"
            self.update_scan_status()
            
            # Run vulnerability tests
            urls_to_scan = list(self.visited_urls)
            with ThreadPoolExecutor(max_workers=self.threads) as executor:
                # Submit URL scanning tasks
                for url in urls_to_scan:
                    executor.submit(self.scan_url_with_progress, url)
                
                # Submit form testing tasks
                for form in self.forms:
                    executor.submit(self.test_form, form)
            
            # Mark scan as completed if not cancelled
            if not self.should_cancel:
                self.scan_status = "Completed"
                self.scan_progress = 100
                self.db.execute(
                    "UPDATE scans SET completed = ?, progress = ?, status = ? WHERE id = ?",
                    (True, 100, "Completed", self.scan_id)
                )
            
            logger.info(f"Scan completed. Found {len(self.vulnerabilities)} vulnerabilities.")
            return self.vulnerabilities
            
        except Exception as e:
            logger.error(f"Error during scan: {str(e)}")
            self.scan_status = f"Error: {str(e)}"
            self.update_scan_status()
            return []
    
    def update_scan_status(self):
        """Update scan status in the database"""
        if hasattr(self, 'scan_id'):
            # Calculate progress percentage
            if self.total_urls > 0:
                self.scan_progress = min(99, int((self.scanned_urls / self.total_urls) * 100))
            
            # Update database
            self.db.execute(
                "UPDATE scans SET progress = ?, scanned_urls = ?, status = ? WHERE id = ?",
                (self.scan_progress, self.scanned_urls, self.scan_status, self.scan_id)
            )
    
    def pause_scan(self):
        """Pause the current scan"""
        self.is_paused = True
        self.scan_status = "Paused"
        self.update_scan_status()
        return True

    def resume_scan(self):
        """Resume a paused scan"""
        self.is_paused = False
        self.scan_status = "Scanning for vulnerabilities"
        self.update_scan_status()
        return True

    def cancel_scan(self):
        """Cancel the current scan"""
        self.should_cancel = True
        self.scan_status = "Cancelled"
        self.update_scan_status()
        
        # Update database to mark scan as completed
        self.db.execute(
            "UPDATE scans SET completed = ?, progress = ?, status = ? WHERE id = ?",
            (True, 100, "Cancelled", self.scan_id)
        )
        return True
    
    def scan_url_with_progress(self, url):
        """Scan a URL and update progress"""
        try:
            # Check if scan should be cancelled
            if self.should_cancel:
                return
                
            # Wait while scan is paused
            while self.is_paused and not self.should_cancel:
                time.sleep(1)
                
            # If scan was cancelled while paused, exit
            if self.should_cancel:
                return
                
            self.scan_url(url)
        finally:
            # Update progress regardless of success or failure
            self.scanned_urls += 1
            self.update_scan_status()
    
    def crawl(self, url, depth):
        """
        Crawl the website to discover URLs and forms
        
        Args:
            url (str): URL to crawl
            depth (int): How many more levels to crawl
        """
        if depth <= 0 or url in self.visited_urls:
            return
        
        # Check if scan should be cancelled
        if self.should_cancel:
            return
            
        # Wait while scan is paused
        while self.is_paused and not self.should_cancel:
            time.sleep(1)
            
        # If scan was cancelled while paused, exit
        if self.should_cancel:
            return
        
        try:
            logger.info(f"Crawling: {url}")
            self.visited_urls.add(url)
            
            response = self.session.get(url, timeout=self.timeout)
            soup = BeautifulSoup(response.text, 'html.parser')
            
            # Extract all links
            for link in soup.find_all('a', href=True):
                href = link['href']
                next_url = urllib.parse.urljoin(url, href)
                
                # Only follow links to the same domain
                if self.base_url in next_url and '#' not in next_url:
                    self.crawl(next_url, depth - 1)
            
            # Extract all forms
            for form in soup.find_all('form'):
                form_info = {
                    'action': urllib.parse.urljoin(url, form.get('action', '')),
                    'method': form.get('method', 'get').lower(),
                    'inputs': []
                }
                
                for input_field in form.find_all(['input', 'textarea', 'select']):
                    input_type = input_field.get('type', '')
                    input_name = input_field.get('name', '')
                    
                    if input_name and input_type != 'submit':
                        form_info['inputs'].append({
                            'name': input_name,
                            'type': input_type
                        })
                
                if form_info['inputs']:
                    self.forms.append(form_info)
        
        except requests.RequestException as e:
            logger.warning(f"Error crawling {url}: {str(e)}")
    
    def scan_url(self, url):
        """
        Scan a URL for various vulnerabilities
        
        Args:
            url (str): URL to scan
        """
        try:
            # Check if scan is paused or cancelled
            if self.should_cancel:
                return
                
            while self.is_paused and not self.should_cancel:
                time.sleep(1)
                
            if self.should_cancel:
                return

            # Test for XSS vulnerabilities in URL parameters
            self.test_xss(url)
            
            # Test for SQL injection in URL parameters
            self.test_sql_injection(url)
            
            # Test for open redirects
            self.test_open_redirect(url)
            
            # Test for sensitive information disclosure
            self.test_info_disclosure(url)
            
        except Exception as e:
            logger.error(f"Error scanning {url}: {str(e)}")
    
    def test_form(self, form):
        """
        Test a form for various vulnerabilities
        
        Args:
            form (dict): Form information dictionary
        """
        try:
            # Check if scan is paused or cancelled
            if self.should_cancel:
                return
                
            while self.is_paused and not self.should_cancel:
                time.sleep(1)
                
            if self.should_cancel:
                return
                
            # Test for XSS vulnerabilities
            self.test_form_xss(form)
            
            # Test for SQL injection
            self.test_form_sql_injection(form)
            
            # Test for CSRF vulnerabilities
            self.test_csrf(form)
            
        except Exception as e:
            logger.error(f"Error testing form {form['action']}: {str(e)}")
    
    def test_xss(self, url):
        """Test for XSS vulnerabilities in URL parameters"""
        parsed_url = urllib.parse.urlparse(url)
        params = urllib.parse.parse_qs(parsed_url.query)
        
        if not params:
            return
        
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "';alert(String.fromCharCode(88,83,83))//';alert(String.fromCharCode(88,83,83))//\";"
        ]
        
        for param_name in params:
            for payload in xss_payloads:
                # Check if scan is paused or cancelled
                if self.should_cancel:
                    return
                    
                while self.is_paused and not self.should_cancel:
                    time.sleep(1)
                    
                if self.should_cancel:
                    return
                    
                test_params = params.copy()
                test_params[param_name] = [payload]
                query_string = urllib.parse.urlencode(test_params, doseq=True)
                test_url = urllib.parse.urlunparse(
                    (parsed_url.scheme, parsed_url.netloc, parsed_url.path, 
                     parsed_url.params, query_string, parsed_url.fragment)
                )
                
                try:
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    # Check if the payload is reflected in the response
                    if payload in response.text and not response.text.find(f"escaped{payload}"):
                        self.add_vulnerability(
                            url=url,
                            vulnerability_type="XSS",
                            description=f"Reflected XSS vulnerability found in parameter '{param_name}'",
                            severity="High",
                            evidence=f"Payload: {payload}"
                        )
                        break
                
                except requests.RequestException:
                    pass
    
    def test_sql_injection(self, url):
        """Test for SQL injection vulnerabilities in URL parameters"""
        parsed_url = urllib.parse.urlparse(url)
        params = urllib.parse.parse_qs(parsed_url.query)
        
        if not params:
            return
        
        sql_payloads = [
            "' OR '1'='1",
            "1' OR '1'='1' --",
            "' UNION SELECT 1,2,3 --",
            "1; DROP TABLE users --"
        ]
        
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-01756",
            "SQLite3::query",
            "SQLSTATE[",
            "Microsoft SQL Server",
            "PostgreSQL",
            "mysqli_fetch_array"
        ]
        
        for param_name in params:
            for payload in sql_payloads:
                # Check if scan is paused or cancelled
                if self.should_cancel:
                    return
                    
                while self.is_paused and not self.should_cancel:
                    time.sleep(1)
                    
                if self.should_cancel:
                    return
                    
                test_params = params.copy()
                test_params[param_name] = [payload]
                query_string = urllib.parse.urlencode(test_params, doseq=True)
                test_url = urllib.parse.urlunparse(
                    (parsed_url.scheme, parsed_url.netloc, parsed_url.path, 
                     parsed_url.params, query_string, parsed_url.fragment)
                )
                
                try:
                    response = self.session.get(test_url, timeout=self.timeout)
                    
                    # Check for SQL error messages
                    for error in sql_errors:
                        if error in response.text:
                            self.add_vulnerability(
                                url=url,
                                vulnerability_type="SQL Injection",
                                description=f"Possible SQL injection vulnerability found in parameter '{param_name}'",
                                severity="High",
                                evidence=f"Payload: {payload}, Error: {error}"
                            )
                            break
                
                except requests.RequestException:
                    pass
    
    def test_open_redirect(self, url):
        """Test for open redirect vulnerabilities"""
        parsed_url = urllib.parse.urlparse(url)
        params = urllib.parse.parse_qs(parsed_url.query)
        
        redirect_params = ['redirect', 'url', 'return', 'next', 'redir', 'destination', 'redirect_uri']
        test_domains = ['evil.com', 'attacker.org', 'malicious.net']
        
        for param_name in params:
            if any(redirect_param in param_name.lower() for redirect_param in redirect_params):
                for domain in test_domains:
                    # Check if scan is paused or cancelled
                    if self.should_cancel:
                        return
                        
                    while self.is_paused and not self.should_cancel:
                        time.sleep(1)
                        
                    if self.should_cancel:
                        return
                        
                    test_params = params.copy()
                    test_params[param_name] = [f'https://{domain}']
                    query_string = urllib.parse.urlencode(test_params, doseq=True)
                    test_url = urllib.parse.urlunparse(
                        (parsed_url.scheme, parsed_url.netloc, parsed_url.path, 
                         parsed_url.params, query_string, parsed_url.fragment)
                    )
                    
                    try:
                        response = self.session.get(test_url, timeout=self.timeout, allow_redirects=False)
                        
                        if response.status_code in (301, 302, 303, 307, 308):
                            redirect_url = response.headers.get('Location', '')
                            if domain in redirect_url:
                                self.add_vulnerability(
                                    url=url,
                                    vulnerability_type="Open Redirect",
                                    description=f"Open redirect vulnerability found in parameter '{param_name}'",
                                    severity="Medium",
                                    evidence=f"Redirects to: {redirect_url}"
                                )
                                break
                    
                    except requests.RequestException:
                        pass
    
    def test_info_disclosure(self, url):
        """Test for sensitive information disclosure"""
        try:
            # Check if scan is paused or cancelled
            if self.should_cancel:
                return
                
            while self.is_paused and not self.should_cancel:
                time.sleep(1)
                
            if self.should_cancel:
                return
                
            response = self.session.get(url, timeout=self.timeout)
            page_content = response.text
            
            patterns = {
                "Email Address": r"[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}",
                "API Key": r"(?i)(api[_-]?key|secret[_-]?key)['\"]?\s*[:=]\s*['\"]?([a-zA-Z0-9]{16,})['\"a-zA-Z0-9]?",
                "AWS Key": r"(?i)AKIA[0-9A-Z]{16}",
                "IP Address": r"\b(?:\d{1,3}\.){3}\d{1,3}\b",
                "Social Security Number": r"\b\d{3}-\d{2}-\d{4}\b",
                "Credit Card Number": r"\b(?:\d{4}[- ]?){3}\d{4}\b"
            }
            
            for pattern_name, pattern in patterns.items():
                matches = re.findall(pattern, page_content)
                if matches:
                    self.add_vulnerability(
                        url=url,
                        vulnerability_type="Information Disclosure",
                        description=f"Possible {pattern_name} found in page content",
                        severity="Medium",
                        evidence=f"Found matches: {str(matches)[:100]}..."
                    )
        
        except requests.RequestException:
            pass
    
    def test_form_xss(self, form):
        """Test form inputs for XSS vulnerabilities"""
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "';alert(String.fromCharCode(88,83,83))//';alert(String.fromCharCode(88,83,83))//\";"
        ]
        
        for payload in xss_payloads:
            # Check if scan is paused or cancelled
            if self.should_cancel:
                return
                
            while self.is_paused and not self.should_cancel:
                time.sleep(1)
                
            if self.should_cancel:
                return
                
            data = {}
            for input_field in form['inputs']:
                data[input_field['name']] = payload
            
            try:
                if form['method'] == 'post':
                    response = self.session.post(form['action'], data=data, timeout=self.timeout)
                else:
                    response = self.session.get(form['action'], params=data, timeout=self.timeout)
                
                if payload in response.text and not response.text.find(f"escaped{payload}"):
                    self.add_vulnerability(
                        url=form['action'],
                        vulnerability_type="XSS",
                        description="Reflected XSS vulnerability found in form",
                        severity="High",
                        evidence=f"Form action: {form['action']}, Payload: {payload}"
                    )
                    break
            
            except requests.RequestException:
                pass
    
    def test_form_sql_injection(self, form):
        """Test form inputs for SQL injection vulnerabilities"""
        sql_payloads = [
            "' OR '1'='1",
            "1' OR '1'='1' --",
            "' UNION SELECT 1,2,3 --",
            "1; DROP TABLE users --"
        ]
        
        sql_errors = [
            "SQL syntax",
            "mysql_fetch_array",
            "ORA-01756",
            "SQLite3::query",
            "SQLSTATE[",
            "Microsoft SQL Server",
            "PostgreSQL",
            "mysqli_fetch_array"
        ]
        
        for payload in sql_payloads:
            for input_field in form['inputs']:
                # Check if scan is paused or cancelled
                if self.should_cancel:
                    return
                    
                while self.is_paused and not self.should_cancel:
                    time.sleep(1)
                    
                if self.should_cancel:
                    return
                    
                data = {}
                
                # Set payload for current field, empty string for others
                for field in form['inputs']:
                    if field['name'] == input_field['name']:
                        data[field['name']] = payload
                    else:
                        data[field['name']] = ""
                
                try:
                    if form['method'] == 'post':
                        response = self.session.post(form['action'], data=data, timeout=self.timeout)
                    else:
                        response = self.session.get(form['action'], params=data, timeout=self.timeout)
                    
                    for error in sql_errors:
                        if error in response.text:
                            self.add_vulnerability(
                                url=form['action'],
                                vulnerability_type="SQL Injection",
                                description=f"Possible SQL injection vulnerability found in form field '{input_field['name']}'",
                                severity="High",
                                evidence=f"Form action: {form['action']}, Payload: {payload}, Error: {error}"
                            )
                            break
                
                except requests.RequestException:
                    pass
    
    def test_csrf(self, form):
        """Test for CSRF vulnerabilities in forms"""
        # Check if scan is paused or cancelled
        if self.should_cancel:
            return
            
        while self.is_paused and not self.should_cancel:
            time.sleep(1)
            
        if self.should_cancel:
            return
            
        # Check if the form has CSRF protection
        csrf_fields = ['csrf', 'token', 'nonce', '_token']
        
        has_csrf_protection = False
        for input_field in form['inputs']:
            if any(csrf_field in input_field['name'].lower() for csrf_field in csrf_fields):
                has_csrf_protection = True
                break
        
        if not has_csrf_protection and form['method'] == 'post':
            self.add_vulnerability(
                url=form['action'],
                vulnerability_type="CSRF",
                description="Form lacks CSRF protection",
                severity="Medium",
                evidence=f"Form action: {form['action']}, Method: {form['method']}"
            )
    
    def add_vulnerability(self, url, vulnerability_type, description, severity, evidence):
        """Add a vulnerability to the database and in-memory list"""
        logger.info(f"Found vulnerability: {vulnerability_type} at {url}")
        
        vulnerability = {
            'url': url,
            'type': vulnerability_type,
            'description': description,
            'severity': severity,
            'evidence': evidence
        }
        
        self.vulnerabilities.append(vulnerability)
        
        # Add to database
        self.db.execute(
            """
            INSERT INTO vulnerabilities 
            (scan_id, url, vulnerability_type, description, severity, evidence) 
            VALUES (?, ?, ?, ?, ?, ?)
            """,
            (self.scan_id, url, vulnerability_type, description, severity, evidence)
        )
    
    def get_scan_results(self, scan_id=None):
        """Get the results of a scan from the database"""
        if scan_id is None:
            scan_id = self.scan_id
        
        results, _ = self.db.execute(
            """
            SELECT v.id, v.scan_id, v.url, v.vulnerability_type, v.description, v.severity, v.evidence,
                   s.target_url, s.scan_date, s.progress, s.status 
            FROM vulnerabilities v
            JOIN scans s ON v.scan_id = s.id
            WHERE v.scan_id = ?
            """,
            (scan_id,)
        )
        
        vulnerabilities = []
        scan_info = None
        
        for row in results:
            if scan_info is None and len(results) > 0:
                scan_info = {
                    'progress': row['progress'],
                    'status': row['status']
                }
                
            vulnerabilities.append({
                'id': row['id'],
                'scan_id': row['scan_id'],
                'url': row['url'],
                'type': row['vulnerability_type'],
                'description': row['description'],
                'severity': row['severity'],
                'evidence': row['evidence'],
                'target_url': row['target_url'],
                'scan_date': row['scan_date']
            })
        
        # If no vulnerabilities found yet, still get scan info
        if not vulnerabilities:
            scan_results, _ = self.db.execute(
                "SELECT progress, status, total_urls, scanned_urls FROM scans WHERE id = ?",
                (scan_id,)
            )
            if scan_results:
                scan_info = {
                    'progress': scan_results[0]['progress'],
                    'status': scan_results[0]['status'],
                    'total_urls': scan_results[0]['total_urls'],
                    'scanned_urls': scan_results[0]['scanned_urls']
                }
        
        return vulnerabilities, scan_info
    
    def get_all_scans(self):
        """Get a list of all scans"""
        results, _ = self.db.execute(
            "SELECT id, target_url, scan_date, completed, progress, status FROM scans ORDER BY scan_date DESC"
        )
        
        scans = []
        for row in results:
            scans.append({
                'id': row['id'],
                'target_url': row['target_url'],
                'scan_date': row['scan_date'],
                'completed': bool(row['completed']),
                'progress': row['progress'],
                'status': row['status']
            })
        
        return scans
    
    def close(self):
        """Close database connection"""
        self.db.close_all()


class VulnerabilityAPI:
    def __init__(self):
        """Initialize the API for the vulnerability scanner"""
        self.scanner = None
        self.active_scans = {}
    
    def start_scan(self, url, depth=2, threads=5, timeout=10):
        """Start a new vulnerability scan"""
        try:
            self.scanner = VulnerabilityScanner(base_url=url, depth=depth, threads=threads, timeout=timeout)
            
            # Initialize scan in database to get scan_id before starting thread
            results, scan_id = self.scanner.db.execute(
                "INSERT INTO scans (target_url, scan_date, completed, status) VALUES (?, ?, ?, ?)",
                (url, datetime.now(), False, "Initializing")
            )
            self.scanner.scan_id = scan_id
            
            # Store scanner in active_scans dict
            self.active_scans[scan_id] = self.scanner
            
            # Start the scan in a background thread
            scan_thread = threading.Thread(target=self.scanner.start_scan)
            scan_thread.daemon = True
            scan_thread.start()
            
            return {
                'success': True,
                'scan_id': self.scanner.scan_id,
                'message': 'Scan started successfully'
            }
        except Exception as e:
            logger.error(f"Error starting scan: {str(e)}")
            return {
                'success': False,
                'error': str(e)
            }
    
    def pause_scan(self, scan_id):
        """Pause a running scan"""
        try:
            if scan_id in self.active_scans:
                scanner = self.active_scans[scan_id]
                result = scanner.pause_scan()
                return {
                    'success': result,
                    'message': 'Scan paused successfully'
                }
            else:
                # Try to find the scanner instance
                self.scanner = VulnerabilityScanner(base_url="temp")
                self.scanner.scan_id = scan_id
                result = self.scanner.pause_scan()
                return {
                    'success': result,
                    'message': 'Scan paused successfully'
                }
        except Exception as e:
            logger.error(f"Error pausing scan: {str(e)}")
            return {
                'success': False,
                'error': str(e)
            }
    
    def resume_scan(self, scan_id):
        """Resume a paused scan"""
        try:
            if scan_id in self.active_scans:
                scanner = self.active_scans[scan_id]
                result = scanner.resume_scan()
                return {
                    'success': result,
                    'message': 'Scan resumed successfully'
                }
            else:
                # Try to find the scanner instance
                self.scanner = VulnerabilityScanner(base_url="temp")
                self.scanner.scan_id = scan_id
                result = self.scanner.resume_scan()
                return {
                    'success': result,
                    'message': 'Scan resumed successfully'
                }
        except Exception as e:
            logger.error(f"Error resuming scan: {str(e)}")
            return {
                'success': False,
                'error': str(e)
            }
    
    def cancel_scan(self, scan_id):
        """Cancel a running scan"""
        try:
            if scan_id in self.active_scans:
                scanner = self.active_scans[scan_id]
                result = scanner.cancel_scan()
                return {
                    'success': result,
                    'message': 'Scan cancelled successfully'
                }
            else:
                # Try to find the scanner instance
                self.scanner = VulnerabilityScanner(base_url="temp")
                self.scanner.scan_id = scan_id
                result = self.scanner.cancel_scan()
                return {
                    'success': result,
                    'message': 'Scan cancelled successfully'
                }
        except Exception as e:
            logger.error(f"Error cancelling scan: {str(e)}")
            return {
                'success': False,
                'error': str(e)
            }
            
    def delete_scan(self, scan_id):
        """Delete a scan and its results from the database"""
        try:
            if self.scanner is None:
                self.scanner = VulnerabilityScanner(base_url="temp")
                
            # Delete vulnerabilities associated with this scan
            self.scanner.db.execute(
                "DELETE FROM vulnerabilities WHERE scan_id = ?", 
                (scan_id,)
            )
            
            # Delete the scan record
            self.scanner.db.execute(
                "DELETE FROM scans WHERE id = ?", 
                (scan_id,)
            )
            
            # Remove from active scans if present
            if scan_id in self.active_scans:
                del self.active_scans[scan_id]
                
            return {
                'success': True,
                'message': 'Scan deleted successfully'
            }
        except Exception as e:
            logger.error(f"Error deleting scan: {str(e)}")
            return {
                'success': False,
                'error': str(e)
            }
        # Missing methods for VulnerabilityAPI
def get_all_scans(self):
    """Get a list of all scans"""
    try:
        if self.scanner is None:
            self.scanner = VulnerabilityScanner(base_url="temp")
        
        scans = self.scanner.get_all_scans()
        return {
            'success': True,
            'scans': scans
        }
    except Exception as e:
        logger.error(f"Error getting all scans: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

def get_scan_results(self, scan_id):
    """Get the results of a specific scan"""
    try:
        if scan_id in self.active_scans:
            scanner = self.active_scans[scan_id]
            results, scan_info = scanner.get_scan_results(scan_id)
        else:
            if self.scanner is None:
                self.scanner = VulnerabilityScanner(base_url="temp")
            
            results, scan_info = self.scanner.get_scan_results(scan_id)
        
        return {
            'success': True,
            'results': results,
            'scan_info': scan_info
        }
    except Exception as e:
        logger.error(f"Error getting scan results: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

# Add methods to VulnerabilityAPI class
VulnerabilityAPI.get_all_scans = get_all_scans
VulnerabilityAPI.get_scan_results = get_scan_results
        # Create a Flask API to serve the vulnerability scanner
from flask import Flask, request, jsonify, send_from_directory
from flask_cors import CORS
import os

# Set up the Flask application
app = Flask(__name__, static_folder='frontend/build')
CORS(app)

api = VulnerabilityAPI()

@app.route('/api/scan', methods=['POST'])
def start_scan():
    """API endpoint to start a new scan"""
    data = request.json
    
    if not data or 'url' not in data:
        return jsonify({'success': False, 'error': 'URL is required'}), 400
    
    url = data['url']
    depth = int(data.get('depth', 2))
    threads = int(data.get('threads', 5))
    timeout = int(data.get('timeout', 10))
    
    result = api.start_scan(url, depth, threads, timeout)
    return jsonify(result)

@app.route('/api/scans', methods=['GET'])
def get_all_scans():
    """API endpoint to get all scans"""
    result = api.get_all_scans()
    return jsonify(result)

@app.route('/api/scans/<int:scan_id>', methods=['GET'])
def get_scan_results(scan_id):
    """API endpoint to get results of a specific scan"""
    result = api.get_scan_results(scan_id)
    return jsonify(result)

@app.route('/api/scans/<int:scan_id>/status', methods=['GET'])
def get_scan_status(scan_id):
    """API endpoint to get the status of a specific scan"""
    result = api.get_scan_status(scan_id)
    return jsonify(result)

@app.route('/api/scans/<int:scan_id>/pause', methods=['POST'])
def pause_scan(scan_id):
    """API endpoint to pause a running scan"""
    result = api.pause_scan(scan_id)
    return jsonify(result)

@app.route('/api/scans/<int:scan_id>/resume', methods=['POST'])
def resume_scan(scan_id):
    """API endpoint to resume a paused scan"""
    result = api.resume_scan(scan_id)
    return jsonify(result)

@app.route('/api/scans/<int:scan_id>/cancel', methods=['POST'])
def cancel_scan(scan_id):
    """API endpoint to cancel a running scan"""
    result = api.cancel_scan(scan_id)
    return jsonify(result)

@app.route('/api/scans/<int:scan_id>', methods=['DELETE'])
def delete_scan(scan_id):
    """API endpoint to delete a scan and its results"""
    result = api.delete_scan(scan_id)
    return jsonify(result)

@app.route('/api')
def api_info():
    """Return API information"""
    return jsonify({
        "status": "running",
        "message": "Vulnerability Scanner API is running. Access endpoints at /api/scan, /api/scans, etc.",
        "endpoints": [
            {"path": "/api/scan", "method": "POST", "description": "Start a new scan"},
            {"path": "/api/scans", "method": "GET", "description": "Get all scans"},
            {"path": "/api/scans/<scan_id>", "method": "GET", "description": "Get results of a specific scan"},
            {"path": "/api/scans/<scan_id>/status", "method": "GET", "description": "Get status of a specific scan"}
        ]
    })

# This route will serve the frontend files
@app.route('/', defaults={'path': ''})
@app.route('/<path:path>')
def serve_frontend(path):
    """Serve the frontend application"""
    # First, check if the path exists as a file in the static folder
    if path and os.path.exists(os.path.join(app.static_folder, path)):
        return send_from_directory(app.static_folder, path)
    else:
        # If not found, or if it's the root path, serve index.html
        return send_from_directory(app.static_folder, 'index.html')

# Add get_scan_status method to VulnerabilityAPI class
def get_scan_status(self, scan_id):
    """Get the status of a specific scan"""
    try:
        if scan_id in self.active_scans:
            scanner = self.active_scans[scan_id]
            _, scan_info = scanner.get_scan_results(scan_id)
        else:
            if self.scanner is None:
                self.scanner = VulnerabilityScanner(base_url="temp")
            
            _, scan_info = self.scanner.get_scan_results(scan_id)
        
        return {
            'success': True,
            'scan_info': scan_info
        }
    except Exception as e:
        logger.error(f"Error getting scan status: {str(e)}")
        return {
            'success': False,
            'error': str(e)
        }

# Add the method to the VulnerabilityAPI class
VulnerabilityAPI.get_scan_status = get_scan_status

# Add debug output
print("Starting Flask server...")
print(f"Serving static files from: {os.path.abspath(app.static_folder)}")

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Web Application Vulnerability Scanner')
    parser.add_argument('--mode', choices=['cli', 'api'], default='api', help='Run in CLI or API mode')
    parser.add_argument('--url', help='Target URL to scan (required in CLI mode)')
    parser.add_argument('--depth', type=int, default=2, help='Crawl depth')
    parser.add_argument('--threads', type=int, default=5, help='Number of threads')
    parser.add_argument('--timeout', type=int, default=10, help='Request timeout in seconds')
    parser.add_argument('--host', default='127.0.0.1', help='API host (API mode only)')
    parser.add_argument('--port', type=int, default=8080, help='API port (API mode only)')
    
    args = parser.parse_args()
    
    if args.mode == 'cli':
        if not args.url:
            print("Error: URL is required in CLI mode")
            parser.print_help()
            exit(1)
        
        scanner = VulnerabilityScanner(
            base_url=args.url,
            depth=args.depth,
            threads=args.threads,
            timeout=args.timeout
        )
        
        print(f"Starting scan of {args.url}...")
        results = scanner.start_scan()
        
        print("\nScan Results:")
        for vulnerability in results:
            print(f"\nType: {vulnerability['type']}")
            print(f"URL: {vulnerability['url']}")
            print(f"Severity: {vulnerability['severity']}")
            print(f"Description: {vulnerability['description']}")
            print(f"Evidence: {vulnerability['evidence']}")
        
        print(f"\nTotal vulnerabilities found: {len(results)}")
        
        scanner.close()
    else:
        print(f"Starting API server on {args.host}:{args.port}...")
        app.run(host=args.host, port=args.port, debug=True)